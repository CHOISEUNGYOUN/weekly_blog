# Chapter 10 Rounding Errors (반올림 에러)

## 목표 - 정수 대신 소수 사용하기
때때로 1 이나 327, -19 와 같은 정수형 데이터 대신 2.5 와 같은 소수형 데이터를 저장해야 하는 경우가 있다. 이는 보통 정수형 데이터가 제공하는 값보다 더 세밀한 값을 요구하는 경우가 발생하기 때문이다. 여기에 추가로 계산을 하더라도 반드시 정확한 결과값을 산출해는 것 또한 내재되어 있다.

## 안티패턴 - FLOAT 데이터형 사용하기
많은 프로그래밍 언어에서 `float` 또는 `double` 데이터 타입을 소수형 데이터를 표현하기 위해 사용한다. SQL 또한 동일한 이름을 가진 데이터 타입을 가지고 있다. SQL에서 `FLOAT`을 처리하는 방식은 [`IEEE 754`](https://ko.wikipedia.org/wiki/IEEE_754) 기준에 의거하여 입력값을 이진 포멧으로 변환하는 방식을 채택하고 있다.

### 필요에 의한 반올림
많은 개발자들은 부동소수점의 특징에 대해 제대로 이해하고 있지 않다. 여기서 말하고자 하는 바는 십진수로 표현된 모든 데이터가 이진수로 저장되지 않는다는 것이다. 어쩔 수 없이 특정 숫자값은 가장 근사값으로 반올림이 되어야 한다. 예를 들어 1/3 + 1/3 + 1/3 은 1이 될 수 있지만 1/3을 소수로 바꾸는 경우 `0.33333...` 이 되기 때문에 어쩔 수 없이 오차값이 발생한다. 이 경우 `0.333...` + `0.333...` + `0.333...` 을 하더라도 1이 될 수 없다. 이 경우처럼 십진수를 이진수로 변환하는 과정에서 오차가 발생한다. 이와 동일한 이유로 59.95 를 float 형태의 부동소수로 저장하는 경우 59.950000762939 로 변환되어 저장된다.

특정 데이터베이스는 `DOUBLE PRECISION` 와 `REAL` 데이터 타입을 지원하긴 하지만 이 또한 부동소수를 이진수로 변환하여 저장하기 때문에 위와 비슷한 문제를 안고있다.

### SQL에서 FLOAT 사용하기
```sql
SELECT hourly_rate FROM Accounts WHERE account_id = 123;
# return 59.95
```
특정 데이터베이스는 이러한 부정확성을 보정해주는 기능을 탑재하고 있다. 하지만 `FLOAT` 컬럼에 저장된 데이터는 실제 저장한 값과 다르다.

```sql
SELECT hourly_rate * 1000000000 FROM Accounts WHERE account_id = 123;
# return 59950000762.939
```

우리는 위 쿼리를 실행 했을 때 59950000000.000 가 출력되는 것을 기대했지만 59.95 에서 소수점 값이 반올림되어 저장되어 있는 것을 확인 할 수 있다. 이 문제는 또한 아래와 같은 현상을 야기시킨다.

```sql
SELECT * FROM Accounts WHERE hourly_rate = 59.95;
# return no rows match.
```
데이터베이스에 59.95 가 아니라 소숫점이 반올림 된 값이 저장되어 있기 때문에 정확하기 일치하지 않음을 보여준다. 이러한 문제를 보정해주기 위해 `ABS()` 함수를 사용하여 절대값의 오차를 계산하여 유효한 값을 찾기도 한다.

```sql
SELECT * FROM Accounts WHERE ABS(hourly_rate - 59.95) < 0.000001;
```
하지만 위 방법도 완벽한 해결책이 될 수 없는 것이 오차값의 크기가 커지면 이러한 방식 또한 동작하지 않기 때문이다.

```sql
SELECT * FROM Accounts WHERE ABS(hourly_rate - 59.95) < 0.0000001;
```

부동소수의 부정확성이 야기하는 또 다른 문제는 통계값을 도출 할 때 발생한다. 반올림하여 저장된 소수값을 합하거나 곱하여 표현하는 경우 우리가 의도했던 결과값을 100% 일치하는 값이 아닌 오차가 발생한다.

```sql
SELECT SUM( b.hours * a.hourly_rate ) AS project_cost
FROM Bugs AS b
JOIN Accounts AS a ON (b.assigned_to = a.account_id);
```

이런 통계값 도출은 집계하는 값이 많으면 많을수록 더 큰 오차를 발생시킨다.

## 어떻게 안티패턴을 구분하는가
`FLOAT`, `REAL`, `DOUBLE PRECISION` 데이터타입을 사용하는 컬럼은 모두 의심의 대상이다. 부동소수점을 필요로 하는 대부분의 어플리케이션은 IEEE 754 표준에 따른 데이터 변환이 필요하지 않다. 많은 프로그래밍 언어에서 `FLOAT` 데이터형을 지원하기 때문에 자연스럽게 사용하지만 SQL에서는 이보다 더 나은 방법이 따로 있다.

## 안티패턴 사용이 정당화 되는 경우
`FLOAT` 데이터타입은 `INTEGER` 나 `NUMERIC` 데이터타입이 지원하는 숫자보다 보다 훨씬 더 큰 범위를 다루는 경우 유용하다. 데이터 사이언스 분야와 같이 큰 숫자를 다루는 경우 유용할 것이다. Oracle DB의 경우 `FLOAT` 데이터타입을 위에서 기술한 내용과 다르게 정확한 숫자를 다룬다. 여기서 언급하는 `FLOAT`의 경우 `BINARY_FLOAT` 이라는 형태로 따로 존재한다.

## 해결책 - `NUMERIC` 데이터타입 사용하기
`FLOAT` 형태 대신 `NUMERIC` 이나 `DECIMAL` 과 같은 부동소수 타입을 사용하면 이러한 문제를 방지 할 수 있다.

```sql
ALTER TABLE Bugs ADD COLUMN hours NUMERIC(9,2);
ALTER TABLE Accounts ADD COLUMN hourly_rate NUMERIC(9,2);
```
이 데이터 타입은 우리가 원하는 값 그대로 데이터베이스에 저장하기 위해 `VARCHAR` 데이터 타입과 같이 전체길이와 소수점 길이를 지정 할 수 있다. 위 형식은 총 길이가 9이고 소수점 길이가 최대 2인 데이터를 저장하겠다는 `DDL`이다. 따라서 `1234567.89`는 저장 할 수 있지만, `12345678.91 (총 길이 초과)` 이나 `123456.789 (소수점 길이 초과)`는 저장할 수 없다.

`NUMERIC` 과 `DECIMAL` 데이터타입의 장점은 십진수를 이진수로 변환하면서 발생하는 부정확성을 완벽하게 보정한다는 것이다. 따라서 아래와 같은 쿼리문들이 제대로 작동함을 확인 할 수 있다.

```sql
SELECT hourly_rate FROM Accounts WHERE hourly_rate = 59.95;
# return 59.95

SELECT hourly_rate * 1000000000 FROM Accounts WHERE hourly_rate = 59.95;
# return 59950000000
```
또한 `NUMERIC` 과 `DECIMAL` 데이터타입은 동일한 방식으로 동작하니 둘 중 선호하는 방식을 선택하여 사용하면 된다.



> 이 글은 [SQL Antipatterns - by Bill Karwin](https://pragprog.com/titles/bksqla/sql-antipatterns/) 영문 원본의 Chapter10 를 요약한 글입니다. 자의적인 해석이 들어 간 것을 참고하셨으면 좋겠습니다.
