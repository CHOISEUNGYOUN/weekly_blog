# Chapter 12 Phantom Files (유령 파일)

## 목표 - 이미지나 벌크 미디어 파일 저장하기
요즘엔 거의 모든 어플리케이션에 이미지나 미디어 파일을 사용하고 있다. 예를 들면 아바타나 프로필 이미지, 또는 버그 리포트를 위한 스크린샷 이미지등 다양한 곳에서 사용되고 있다. 이번 챕터에서는 어떤 방식으로 미디어 데이터를 저장하는 것이 효과적인지 살펴볼 것이다.

## 안티패턴 - 파일로 반드시 사용해야 한다고 확신하기
SQL에서는 이러한 미디어 데이터를 저장하기 위해 `BLOB` 형식의 데이터 타입을 지원한다.
```sql
CREATE TABLE Accounts (
  account_id SERIAL PRIMARY KEY
  account_name VARCHAR(20),
  portrait_image BLOB
);

CREATE TABLE Screenshots (
  bug_id BIGINT UNSIGNED NOT NULL,
  image_id SERIAL NOT NULL,
  screenshot_image BLOB,
  caption VARCHAR(100),
  PRIMARY KEY (bug_id, image_id),
  FOREIGN KEY (bug_id) REFERENCES Bugs(bug_id)
);
```

위와 같이 사용하면 직관적이나 보통 개발자들은 `BLOB` 형식으로 데이터를 DB에 저장하려고 하지 않는다. 대신 해당 파일이 저장된 경로를 `VARCHAR` 형식으로 저장하여 관리한다.

```sql
CREATE TABLE Screenshots (
  bug_id BIGINT UNSIGNED NOT NULL,
  image_id BIGINT UNSIGNED NOT NULL,
  screenshot_path VARCHAR(100),
  caption VARCHAR(100),
  PRIMARY KEY (bug_id, image_id),
  FOREIGN KEY (bug_id) REFERENCES Bugs(bug_id)
);
```
이 문제는 현재도 어떤 것이 옳고 그른지 논란이 많은 주제이다.
>*이 글이 쓰였을 당시에는 그럴만도 하다. 당시에는 클라우드 서비스가 존재하지만 대중화 되어있지 않았기 때문이다. 하지만 요즘의 인프라를 생각해본다면 대부분의 경우 BLOB 형식으로 저장하진 않을 것 같다.)*

하지만 여기서 DB 외부에 저장을 하게되면 어떠한 문제들이 발생하게 되는지 언급해보고자 한다.

### 파일은 `DELETE` 명령어를 실행하지 않는다.
첫번째로 발생하는 문제는 가비지 콜렉션이다. 이미지가 DB 밖에 저장되어 있다면 단순히 로우에 저장된 경로를 제거한다고 해서 해당 이미지 파일이 삭제되지 않는다. 애초에 이렇게 관계가 끊어지더라도 이미지 파일이 삭제되지 않게끔 의도 한 것이 아니라면 이러한 이미지 파일들은 해당 경로에 계속 쌓이게 될 것이다.

### 파일은 트랜잭션 격리가 보장되지 않는다.
보통 `COMMIT` 을 통한 트랜잭션 완료 선언이 되지 않는 이상 데이터가 외부에 노출되지 않는다. 하지만 DB 외부에 해당 파일이 저장되어 있다면 이러한 규칙이 성립되지 않는다. 파일 삭제를 실행하게 되면 클라이언트에서는 즉각적으로 해당 파일에 대한 접근을 할 수 없다. 이와 동일한 맥락으로 파일이 변경되면 즉각적으로 변경된 파일로 노출이 된다.

### 파일은 `ROLLBACK` 기능이 없다.
트랜잭션을 사용할 시 트랜잭션 중 에러가 발생하면 작업중인 로우를 롤백 시킨다. 하지만 이미지의 경우 이러한 트랜잭션에 영향받지 않기 때문에 삭제를 요청하면 즉각적으로 해당 경로에서 사라진다.

### 파일은 DB 백업을 한다고 해서 함께 복원되지 않는다.
많은 SQL DB는 자체적으로 백업 기능을 탑재하고 있다. 이러한 백업 기능은 백업된 DB 데이터의 무결성을 보장해준다. 하지만 경로로 저장된 이미지 파일들은 이러한 데이터 무결성을 보장받지 못한다. 해당 이미지 파일들을 백업을 하기 위해서는 파일 백업 시스템을 사용해야 한다. 하지만 이러한 파일 백업 시스템을 사용하더라도 또 다른 문제가 발생하는데 이는 바로 백업된 파일들이 DB 백업 파일들과 정확하게 일치하는지 여부를 확인하기 힘들기 때문이다.

### 파일은 SQL 접근 권한이 없다.
외부 파일은 GRANT나 REVOKE 같은 SQL문으로 할당한 접근권한을 우회한다.

### 파일은 SQL 데이터 타입이 아니다.
외부 파일은 단지 경로로만 저장되어 있기 때문에 데이터 무결성을 보장하지 못한다. 만약 파일명이나 경로가 바뀌게 된다면 해당 파일 경로를 반드시 직접 수정해주어야만 한다.

## 어떻게 안티패턴을 구분하는가
위와 같은 패턴이 어플리케이션 설계에 있다면 아래와 같은 고민을 하지 않은 것이다.
* 데이터 백업과 복원 절차가 어떻게 되는가? 백업 파일을 검증하는 절차는 어떻게 되는가? 만들어진 백업 데이터를 가지고 데이터 복원을 완전히 다른 DB에 적용해보았는가?
* 이미지 파일이 잘 축적되고 더이상 사용되지 않는 이미지 파일들이 저장소에서 삭제되고 있는가? 삭제되는 절차는 어떻게 되는가? 수동으로 삭제하는가? 아니면 자동으로 삭제되는가?
* 이미지 변경을 중간에 취소 할 수 있는가? 만약 그렇다면 변경되기 이전의 이미지 파일은 복원 되는가?

위의 조건이 무조건 성립되야 하는것은 아니다. 하지만 위의 조건을 성립하는 것이 데이터 무결성 측면에서 가장 이상적인 접근법이다.

## 안티패턴 사용이 정당화 되는 경우
아래와 같은 조건을 인지하고 외부에 이미지나 미디어 파일을 저장하는 경우 적용해도 괜찮다.
* DB에 이미지 파일이 없는 것이 훨씬 유연한 경우. 이미지나 미디어 파일은 대게 많은 용량을 차지하기 때문이다.
* DB 복원시, 이미지 파일이 있으면 DB 크기 때문에 훨씬 작업 속도가 더디다. 이 경우 DB 내부에 이미지 파일을 저장하기 보다 외부에 저장하는 것이 좋다.
* 이미지가 데이터베이스 외부의 파일로 되어 있다면, 일반적인 이미지 미리보기나 편집이 쉽다.

## 해결책 - `BLOB` 데이터 타입을 적절하게 사용하기
이번에 언급한 안티패턴들이 당신의 어플리케이션에서 치명적이다면 `BLOB` 데이터 타입을 사용해서 SQL DB에 직접 저장하는 것을 추천한다. 모든 SQL DB에서 `BLOB` 을 지원하며 해당 데이터는 이진 데이터로 저장된다.

```sql
CREATE TABLE Screenshots (
  bug_id BIGINT UNSIGNED NOT NULL,
  image_id BIGINT UNSIGNED NOT NULL,
  screenshot_image BLOB,
  caption VARCHAR(100),
  PRIMARY KEY (bug_id, image_id),
  FOREIGN KEY (bug_id) REFERENCES Bugs(bug_id)
);
```

`BLOB` 데이터를 사용하면 아래와 같은 문제들을 해결 할 수 있다.
* 이미지 데이터는 DB에 바로 저장된다. 이미지를 불러오기 위해 추가적으로 설정해야 될 절차가 없다. 파일 경로로 불러오는 것이 아니기 때문에 경로에 대한 리스크도 없다.
* 로우 삭제시 이미지도 함께 삭제 된다.
* 트랜잭션이 실패하여 롤백 될 때 이전 상태의 이미지도 함께 복원된다.
* 로우가 업데이트 될 때 해당 로우는 보호되며 다른 클라이언트가 접근하여 업데이트 할 수 없다.
* DB 백업시 이미지 파일도 함께 복원된다.
* SQL 접근권한을 공유한다.

`BLOB` 데이터 타입의 저장가능한 최대 파일 크기는 각 DB 브랜드 마다 상이하지만 대게 어떤 이미지 파일이든 저장할 수 있도록 충분한 크기를 제공해준다. MySQL의 경우 `MEDIUMBLOB` 을 지원해주며 해당 타입은 이미지당 최대 16MB를 저장 할 수 있게끔 지원한다. Oracle의 경우 `LONG RAW` 또는 `BLOB`을 지원해주는데 최대 2 에서 4GB 까지 저장할 수 있도록 지원한다. 다른 DB들도 이러한 수준에서 지원을 해주고 있다.

이미지 파일은 보통 `Images` 경로에 저장되기 때문에 해당 경로에서 `BLOB` 파일을 불러오는 특정 방법을 따라야한다. 몇몇의 DB는 외부 파일을 불러 올수 있는 함수가 있는데, MySQL에서는 `LOAD_FILE()`이라는 함수를 지원한다. 
```sql
UPDATE Screenshots
SET screenshot_image = LOAD_FILE('images/screenshot1234-1.jpg')
WHERE bug_id = 1234 AND image_id = 1;
```

반대로 `BLOB` 컬럼의 데이터를 파일로 저장하는 기능도 제공한다. MySQL에서는 `SELECT` 절에서 `DUMPFILE` 을 추가하면 해당 파일을 저장 할 수 있다.
```sql
SELECT screenshot_image
INTO DUMPFILE 'images/screenshot1234-1.jpg'
FROM Screenshots
WHERE bug_id = 1234 AND image_id =1;
```

이렇게 저장된 이미지 파일을 직접 접근 할 수도 있다. 웹어플리케이션에서 헤더의 컨텐츠 타입을 추가하여 경로를 불러오기만 한다면 사용하는데 큰 문제가 없다.

## 총평
원래 총평을 잘 안남기는데 이번 챕터는 좀 남겨야겠다. 이 쳅터는 개인적으로 10년전 상황과 지금이 많이 바뀌었다는 것을 가장 많이 느낀 부분이다. 이미지 파일을 SQL에 직접 저장하는 경우는 이제 선호되지 않고 AWS S3와 같이 문서형 스토리지 또는 버켓에 저장하여 어플리케이션 단에서 무결성을 보장하는 경우가 더 일반적이기 때문이다. 아무래도 클라우드 환경에서 동작을 하다보니 비용과 속도, 그리고 효율성 측면에서 월등히 앞서는것과 많은 클라우드 서비스에서 여기서 언급한 안티패턴을 어느정도 상쇄시켜주는 옵션들을 제공해주기 때문이 아닐까 생각한다. 아무리 명저라고 하더라도 지금과 맞지않는 부분은 부분적으로만 받아들이는 것이 좋다는 것을 다시한번 느끼게 해준 챕터였다.

> 이 글은 [SQL Antipatterns - by Bill Karwin](https://pragprog.com/titles/bksqla/sql-antipatterns/) 영문 원본의 Chapter12 를 요약한 글입니다. 자의적인 해석이 들어 간 것을 참고하셨으면 좋겠습니다.
