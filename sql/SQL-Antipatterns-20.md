# Chapter 20 Readable Passwords (읽을 수 있는 비밀번호)

## 목표 - 비밀번호를 복구하거나 재설정하기
어떤 어플리케이션이든 비밀번호가 있고 유저들은 자신의 비밀번호를 잊어버리는 것은 불변의 진리이다. 대부분의 어플리케이션에서는 비밀번호 복구나 재설정하는 이메일을 발송하여 이런 문제를 해결한다. 이 방법은 유저 프로필에 이메일이 등록되어있는 경우 사용할 수 있다.

## 안티패턴 - 비밀번호를 평문으로 저장하기
비밀번호 복구 기능에서 자주 발생하는 실수는 유저에게 발송되는 이메일에 해당 유저의 비밀번호를 작성하여 보내는 경우이다. 이는 데이터베이스 설계에 아주 심각한 결함이 있는 증거이며 이를 통해 인증되지 않은 사용자가 권한을 획득해 해당 어플리케이션에 접근 가능하게끔 하는 치명적인 보안 이슈를 야기시킨다.

이번 섹션에서는 비밀번호를 평문으로 저장했을시, 어떤 문제가 발생하는지 예제를 통해 살펴보고자 한다.

### 비밀번호 저장
비밀번호는 보통 `Accounts` 테이블 내 문자열 속성의 컬럼으로 저장된다.
```sql
CREATE TABLE Accounts (
  account_id SERIAL PRIMARY KEY,
  account_name VARCHAR(20) NOT NULL,
  email VARCHAR(100) NOT NULL,
  password VARCHAR(30) NOT NULL
);
```

계정을 생성할때 단순히 문자열 리터럴 형식으로 비밀번호를 추가하여 생성할 수 있다.
```sql
INSERT INTO Accounts (account_id, account_name, email, password)
  VALUES (123, 'billkarwin', 'bill@example.com', 'xyzzy');
```
이렇게 비밀번호를 평문으로 저장하는것은 보안상 위험할 뿐만 아니라 네트워크 상에서도 그대로 드러나게 된다. 공격자가 비밀번호를 추가하는 SQL 선언문을 읽을수 있다면 비밀번호 또한 그대로 드러나게 된다. 이는 비밀번호 변경이나 로그인 시 비밀번호 검증시에도 동일한 위험을 가지고 있다. 해커들은 다양한 방법으로 사용자의 비밀번호를 탈취 할 수 있게 된다.
* 어플리케이션에서 클라이언트로 전송되는 SQL 선언문이 포함된 네트워크 패킷을 탈취 할 수 있다. 이 방법은 생각보다 훨씬 쉽다. 게다가 이를 손쉽게 수행 할 수 있는 [Wireshark](https://www.wireshark.org/)와 같은 무료 소프트웨어도 존재한다.
* 데이터베이스 서버에서 SQL로그를 검색 할 수 있다. 공격자는 데이터베이스 서버 호스트에 접근을 해야하지만 접근이 가능하다면 그들은 해당 호스트에서 SQL 선언문이 담긴 로그파일을 찾을 수 있을 것이다.
* 데이터베이스 백업파일을 탈취할 수도 있다. 백업 솔루션이 안전한지는 아무도 확신 할 수 없다.

### 비밀번호 인가
이후 사용자가 로그인을 시도 할 때, 앱에서 사용자가 입력한 비밀번호를 데이터베이스에 저장된 비밀번호와 비교대조를 할 것이다. 비밀번호를 평문으로 저장했기 때문에 입력한 텍스트 그대로 검증할 것이다. SQL에서는 아래와 같이 비교 할 수 있다.
```sql
SELECT CASE WHEN password = 'opensesame' THEN 1 ELSE 0 END
  AS password_matches
FROM Accounts
WHERE account_id = 123;
```
데이터베이스에 비밀번호를 평문으로 저장해두었기 때문에 사용자의 입력값을 그대로 SQL로 작성하여 전송하게 되는데 이렇게 되면 공격자가 쉽게 탈취 할 수 있게 된다.

### 비밀번호를 이메일로 전송
비밀번호를 평문으로 저장해두었기 때문에 사용자의 비밀번호를 가져오는것은 어려운일이 아니다.
```sql
SELECT account_name, email, password
FROM Accounts
WHERE account_id = 123;
```
이런 경우 사용자가 자신의 비밀번호를 요청하는 경우 쉽게 발송할 수 있다. 아마 이런식으로 비밀번호를 전달해주는 웹사이트를 사용해본적이 있을 것이다. 하지만 사용자 비밀번호를 이메일로 발송하는것은 굉장히 보안에 취약한 행동이다. 해커가 이메일을 탈취, 로깅 및 다른 저장소에 저장할 위험성이 있기 때문이다. 이는 안전한 프로토콜을 사용하여 메일을 열람하거나 메일서버가 안전하게 관리되는 것과는 별개의 문제이다. 이메일은 기본적으로 인터넷을 경우하여 받기 때문에 어떤 형식이든 다른 사이트에서 탈취 당할수 있다.

## 어떻게 안티패턴을 구분하는가
비밀번호를 평문으로 저장하거나 양방향으로 인코딩하여 저장한 경우와 같이 어떤 방식이든 비밀번호를 알아낼 수 있다면 안티패턴이다.

## 안티패턴 사용이 정당화 되는 경우
앱에서 써드파티에 비밀번호를 제공하는 경우가 있는데 이 경우 당신의 앱이 클라이언트 역할을 한다. 이 경우 비밀번호를 반드시 읽을 수 있는 포멧으로 저장해야한다. 평문으로 저장하는 것 대신에 양방향으로 인코딩된 문자열을 저장하면 더 좋다.

식별과 인가를 구분하는 것 또한 중요하다. 식별이 사용자는 원하는 사람이면 누구나 자신을 식별 하는 것이라면 인증은 본인이 바로 그 사람임을 인증하는 것이기 때문이다. 비밀번호는 이를 위해 활용되는 가장 보편적인 방법이다.

숙련된 해커로부터 방어하기 위한 보안책을 충분히 마련하지 못했다면 신뢰할 수 있는 인가 방식보다 효과적인 식별 방식을 고안해야 한다.

모든 소프트웨어 어플리케이션이 공격에 대한 취약성을 가지고 있지도 않고 반드시 보호되야하는 민감한 정보들을 담고 있지는 않다. 예를 들면 내부망에서 몇몇의 사용자들만 알고 사용하는 앱 같은 것들이 있을 것이다. 이런 경우 단순히 동작하는 수준의 식별 및 인가 방식을 적용 할 수 있다.

여기서 주의해야 할 점은 어플리케이션은 초기에 기획한 모습에서 점점 진화하는 경향이 있다는 것이다. 인트라넷에서 사용되던 앱이 외부망에 노출되어 있다면 반드시 보안전문가의 진단을 받아야 할 것이다.

## 해결책 - 솔트 처리된 해시로 비밀번호 저장하기
이 안티패턴의 가장 핵심문제는 비밀번호를 바로 읽을수 있는 형태로 저장되어 있는 것이다. 이를 해결하는 방법은 사용자의 입력값을 비밀번호를 읽지 않고 인가 해주는 것이다.

### 해시함수 이해하기
이 방법은 비밀번호를 단방향 해시함수로 인코딩 하는 방식이다. 이 방식을 적용하면 직관적으로 읽을수 없는 해시 형태의 문자열이 생성된다. 기존에 입력된 비밀번호가 모호하더라도 해시로 인코딩 하게되면 항상 특정 길이의 문자열로 반환하게된다. 예를들어 `SHA-256` 알고리즘으로 `xyzzy` 문자열을 변환하면 256 비트 사이즈로 변환되기에 64자의 16진수 문자열로 인코딩된다.
```sql
SHA2('xyzzy') = '184858a00fd7971f810848266ebcecee5e8b69972c5ffaed622f5ee078671aed'
```
해당 해시함수의 또 다른 특징은 단방향으로 인코딩 된다는 점이다. 해시 알고리즘은 애초에 입력값의 정보를 알아볼 수 없도록 하는 것이 목적이기 때문에 처음에 어떤 값을 입력했는지 알 수 없다. 좋은 해시 알고리즘은 초기 입력값을 알아내기 위해서 수없이 많은 시도를 하게끔 설계된 것이다.

과거에 인기 많았던 해시알고리즘은 `SHA-1` 이었으나 최근에는(당시는 2010년) 160 비트 해시 알고리즘이 충분한 암호화 기능을 가지지 못했다고 평가하고 있다. 미국 국립표준기술연구소(NIST)에서는 2010년 이후에는 SHA-1을 단계적으로 퇴출하고 더 보안기능이 강화된 SHA-256, SHA-384, SHA-512 등의 버전들을 사용할 것을 권고했다. 미국 국립표준기술연구소의 표준을 따르는 것은 자유이나 SHA-256을 비밀번호 암호화에 사용하는것이 바람직하다고 필자는 생각한다.

MD5() 또한 128 비트 해시를 생성하는 알고리즘으로 인기가 많다. 하지만 이 알고리즘 또한 암호학적인 취약점이 발견되어 사용하는것을 권장하지 않는다. 취약점이 있는 알고리즘을 비밀번호와 같이 민감한 정보에 사용하는것은 좋지 않기 때문이다.

### SQL에서 해시 사용하기
예시로 인용한 `Accounts` 테이블을 조금 수정을 해보도록 하겠다. SHA-256 비밀번호 해시는 항상 64자 길이로 고정되어 있으므로 비밀번호 컬럼을 64 길이의 `CHAR` 컬럼으로 변경한다.
```sql
CREATE TABLE Accounts (
  account_id SERIAL PRIMARY KEY,
  account_name VARCHAR(20),
  email VARCHAR(100) NOT NULL,
  password_hash CHAR(64) NOT NULL
);
```
해시 함수는 SQL 표준에 포함되어있지 않기 때문에 각 데이터베이스마다 제공해주는 해시 확장기능을 활용해야 한다. MySQL 6.0.5의 경우 SSL 보조기능에 `SHA2()` 함수가 포함되어 있는데 이 함수는 256 비트 해시를 기본값으로 반환해준다.
```sql
INSERT INTO Accounts (account_id, account_name, email, password_hash)
  VALUES (123, 'billkarwin', 'bill@example.com', SHA2('xyzzy'));
```
사용자 입력값을 검증 할 때는 사용자 입력값에 동일하게 `SHA2()` 해시 함수를 사용해서 데이터베이스에 저장된 비밀번호와 비교대조하면 된다.
```sql
SELECT CASE WHEN password_hash = SHA2('xyzzy') THEN 1 ELSE 0 END
  AS password_matches
FROM Accounts
WHERE account_id = 123;
```

### 해시에 솔트 추가하기
비밀번호 대신에 해시를 저장하더라도 공격자가 데이터베이스에 접근 가능하면 비밀번호가 어떤 사용자 입력값을 통해 변환되었는지 여러차례 시도하여 비교대조 해보는 방식으로 해당값을 탈취할 수도 있다. 이 작업이 시간이 많이 걸릴지 몰라도 공각자가 비교대조 할수 있는 자체 데이터베이스를 마련하고 시도한다면 어떻게든 추출해낼 수 있을것이다.
```sql
CREATE TABLE DictionaryHashes (
  password VARCHAR(100),
  password_hash CHAR(64)
);

SELECT a.account_name, h.password
FROM Accounts AS a JOIN DictionaryHashes AS h
  ON a.password_hash = h.password_hash;
```
이를 무력화하는 하나의 방법으로 `사전 공격 (Dictionary attack)` 이 있는데 이를 무력화 시킬수 있는 방법은 해시에 솔트를 추가하는 것이다. 솔트는 아무런 의미없는 문자열 바이트를 특정 해시에 추가하여 저장하는 방법이다. 사용자가 사전에 들어있는 단어를 택해서 비밀번호를 만들더라도 해시함수에서 솔트를 비밀번호에 추가하기 때문에 공격자의 해시 데이터베이스와 일치하지 않게 된다. 예를 들어 비밀번호가 "password"인 경우 그냥 해시로 만들어진 문자열과 솔트가 추가된 문자열이 다르다는 것을 확인 할 수 있다.
```sql
SHA2('password')
= '5e884898da28047151d0e56f8dc6292773603d0d6aabbdd62a11ef721d1542d8'

SHA2('password-0xT!sp9')
= '7256d8d7741f740ee83ba7a9b30e7ac11fcd9dbd7a0147f4cc83c62dd6e0c45b'
```
각 비밀번호마다 다른 솔트값을 추가하면 공격자는 매번 새로운 테이블을 만들어서 패스워드를 비교대조 해야 할 것이다. 이렇게 구성하면 공격자는 매번 비밀번호를 풀어낼 때마다 처음부터 다시 시작해야 할 것이다.
```sql
CREATE TABLE Accounts (
  account_id SERIAL PRIMARY KEY,
  account_name VARCHAR(20),
  email VARCHAR(100) NOT NULL,
  password_hash CHAR(32) NOT NULL,
  salt BINARY(8) NOT NULL
);

INSERT INTO Accounts (account_id, account_name, email,
    password_hash, salt)
  VALUES (123, 'billkarwin', 'bill@example.com',
    SHA2('xyzzy' || '-0xT!sp9'), '-0xT!sp9');

SELECT (password_hash = SHA2('xyzzy' || salt)) AS password_matches
FROM Accounts
WHERE account_id = 123;
```
가장 적절한 솔트 길이는 8바이트다. 각 비밀번호마다 반드시 무작위로 생성되고 중복되지 않은 솔트를 추가해야한다. 이번 예시는 솔트를 출력가능한 문자열로 제시했지만 실제로 적용할 때는 무작위로 생성해서 추측불가능하게 생성 할 수 있다.

### 비밀번호를 SQL에서 숨기기
비밀번호를 해시함수를 활용해 변환하여 저장하고 솔트를 활용하면 어느정도 충분한 보안기준을 충족했다고 볼 수 있다. 하지만 비밀번호가 입력값이 여전히 SQL에 평문으로 노출되기 때문에 공격자가 네트워크 패킷이나 SQL 쿼리 로그를 탈취할 수도 있다.

이런 위험을 방지하려면 SQL에 비밀번호를 평문으로 보내지 말아야 한다. 이를 위해서는 비밀번호를 해시로 변환하는 작업을 어플리케이션 단에서 수행하고 SQL에다 전달해야 한다. 이렇게 하면 공격자가 비밀번호 해시를 탈취 할 수는 있지만 해당 해시가 어떤 문자열에서 변환되었는지는 알아 볼 수 없을 것이다.

웹 어플리케이션에서는 공격자가 사용자의 비밀번호를 탈취 할 수 있는 또 다른 지점이 있는데 이는 바로 사용자의 브라우저와 웹서버 사이에서 일어나는 통신이다. 사용자가 로그인을 하기 위해 정보를 입력하여 제출하면 브라우저에서는 해당 정보를 평문으로 서버에다 전달하게 된다. 이 경우 사용자의 비밀번호를 브라우저에서 해시로 변환하여 전달할 수도 있지만 이 경우 솔트가 포함된 비밀번호 해시를 먼저 전달해줘야하기 때문에 구조상 부자연스럽다. 이 경우 HTTPS 통신과 같이 안전한 프로토콜을 사용하여 통신을 암호화 하는것이 좋다.

### 비밀번호 복구 대신 비밀번호 초기화 기능 사용하기
이제 비밀번호를 좀 더 안전한 방법으로 저장 할 수 있게 되었다. 그렇지만 우리가 아직 풀지 못한 기능이 있다. 그것은 바로 사용자가 자신의 비밀번호를 잊어버렸을때 복구하는 방법이다. 일단 데이터베이스에 비밀번호 대신 해시로 저장했기 때문에 비밀번호를 복구할 수는 없다. 공격자가 해시를 푸는것과 동일하게 작업하는 것 이외에는 다른 방법이 없기 때문이다. 하지만 사용자에게 다른 방법으로 이 문제를 해결 할 수 있도록 기능을 제공 해 줄 수는 있다. 두가지 간단한 방법에 대해 언급해보고자 한다.

첫번째 대안은 사용자가 비밀번호를 잃어버렸을 경우 어플리케이션에서 사용자에게 임시 비밀번호를 이메일로 보내는 것이다. 여기에 안전장치로 해당 비밀번호는 특정 짧은 시간안에 만료되도록 구성한다. 이렇게 기능을 구현하면 이메일이 탈취되더라도 높은확률로 기간이 만료되었기 때문에 접근을 허가해주지 않을 것이다. 또한 임시비밀번호를 통해 로그인을 한 뒤 반드시 사용자의 비밀번호를 직접 변경하도록 강제해야 할 것이다.

두번째 대안은 새로운 비밀번호를 이메일로 전송하는 것 대신에 고유 토큰을 발행하여 이를 구분자로 활용하는 것이다.
```sql
CREATE TABLE PasswordResetRequest (
  token CHAR(32) PRIMARY KEY,
  account_id BIGINT UNSIGNED NOT NULL,
  expiration TIMESTAMP NOT NULL,
  FOREIGN KEY (account_id) REFERENCES Accounts(account_id)
);

SET @token = MD5('billkarwin' || CURRENT_TIMESTAMP);

INSERT INTO PasswordResetRequest (token, account_id, expiration)
  VALUES (@token, 123, CURRENT_TIMESTAMP + INTERVAL 1 HOUR);
```
그런 뒤에 해당 토큰을 이메일에 실어 보내는 것이다. 사용자 프로필에 다른 매개체로 보낼수 있는 정보가 있다면 꼭 이메일이 아니더라도 SMS와 같은 다른 매개체를 활용하여 전송 할 수도 있다. 이를 통해 비밀번호 변경을 하도록 유도하게 되면 본인이 아닌 다른 사용자가 비밀번호 변경을 시도하더라도 실제 사용자의 이메일로만 해당 내용이 발송되기 때문에 안전하다.

어플리케이션에서 비밀번호 초기화 기능으로 통하는 URI로 요청이 들어오더라도 반드시 토큰이 `PasswordResetRequest` 테이블에 존재하는 토큰값과 동일해야하고 지정된 만료 시간 이내에 수행되어야 한다. 하나의 토큰은 `account_id`로 외래키를 가지고 있기 때문에 오직 하나의 계정에만 발급된다.

물론 다른 악의를 가진 사람이 해당 페이지에 접근 할 수도 있다. 이 경우 간단한 제약을 걸어 해결할 수 있는데 예를 들면 만료 시간을 부여한다던지 스크린 상에서 어떤 계정의 비밀번호가 재설정되는지 보여주지 않는다던지 말이다.

암호학 분야는 지속적으로 발전하며 항상 공격자보다 한발 더 앞서나가려고 노력중이다. 여기서 기술한 방법들은 많은 일반적인 어플리케이션에 적용되면 보안상의 상당한 향상을 꾀할순 있다. 하지만 당신의 어플리케이션이 매우 강력한 보안을 요구한다면 여기서 언급한 방법들보다 훨씬 더 발전된 기술들을 사용해야 할 것이다.

> 이 글은 [SQL Antipatterns - by Bill Karwin](https://pragprog.com/titles/bksqla/sql-antipatterns/) 영문 원본의 Chapter20 를 요약한 글입니다. 자의적인 해석이 들어 간 것을 참고하셨으면 좋겠습니다.