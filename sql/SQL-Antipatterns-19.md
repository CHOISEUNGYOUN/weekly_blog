# Chapter 19 Implicit Columns (명시적이지 않은 컬럼들)

## 목표 - 타이핑 덜 하기
개발자들은 대게 타이핑 하는것을 좋아하지 않는다. 아이러니하게도 이것이 그들의 선택한 직업의 주된 일임에도 말이다. 개발자들이 타이핑을 많이 해야되는 대표적인 작업은 모든 컬럼명을 명시하는 SQL 쿼리를 작성하는 것이다.

```sql
SELECT bug_id, date_reported, summary, description, resolution,
  reported_by, assigned_to, verified_by, status, priority, hours
FROM Bugs;
```

이런 귀찮음 때문에 많은 개발자들이 당연하게 와일드카드(`*`)를 쿼리 작성시 활용한다. `*` 기호는 모든 컬럼을 의미하기 때문에 암시적으로 모든 컬럼의 값을 조회하게 된다. 이는 쿼리문을 간결하게 만들어준다.

```sql
SELECT * FROM Bugs;
```
이와 비슷하게 `INSERT` 문을 작성할때도 컬럼명을 암시적으로 가리키는 기능이 있다. 이는 바로 컬럼에 해당되는 값들을 순차적으로 나열하여 작성하는 경우 컬럼명 없이도 데이터를 추가해주는 기능이다.

```sql
# 컬럼명을 전부 나열하는 경우
INSERT INTO Accounts (account_name, first_name, last_name, email,
  password, portrait_image, hourly_rate) VALUES
  ('bkarwin', 'Bill', 'Karwin', 'bill@example.com', SHA2('xyzzy'), NULL, 49.95);

# 컬럼명을 나열하지 않는 경우
INSERT INTO Accounts VALUES (DEFAULT,
  'bkarwin', 'Bill', 'Karwin', 'bill@example.com', SHA2('xyzzy'), NULL, 49.95);
```

## 안티패턴 - 잘못된 길로 인도하는 지름길
와일드카드와 컬럼명을 명시하지 않고 로우를 추가하는 것이 타이핑을 덜 하게 해주는 역할을 해주지만 이를 남발하면 여러가지 문제점을 낳는다.

### 리팩토링의 어려움
`Bugs` 테이블에 `date_due` 라는 컬럼을 스케쥴 관리 차원에서 추가한다고 가정해보자.
```sql
ALTER TABLE Bugs ADD COLUMN date_due DATE;
```
이 경우 컬럼명 없이 `INSERT` 구문을 선언한 경우 새로운 컬럼에 대한 데이터를 추가하지 않았기 때문에 에러를 발생시킬 것이다.
```sql
INSERT INTO Bugs VALUES (DEFAULT, CURDATE(), 'New bug', 'Test T987 fails...',
  NULL, 123, NULL, NULL, DEFAULT, 'Medium', NULL);

-- SQLSTATE 21S01: Column count doesn't match value count at row 1
```
컬럼명 암시적 선언을 통한 로우 추가를 하는 경우 반드시 모든 로우에 순서대로 값을 넣어줘야 한다. 컬럼이 변경되면 에러를 발생하기도 하고 심지어 잘못된 데이터를 바꿔 넣는 실수를 할 수도 있다.

와일드카드를 사용하는 경우 컬럼명을 모르기 때문에 컬럼이 선언된 순서대로 데이터를 반환한다. 이 경우 조심해야될 점은 컬럼의 순서가 변경되거나 중간에 삭제하는 경우 순서가 달라지기 때문에 문제가 발생한다는 점이다.

```sql
ALTER TABLE Bugs DROP COLUMN verified_by;
```
이런 사소한 문제 때문에 에러가 전체 어플리케이션으로 전파되어 서비스가 중단되는 문제를 발생시킬수도 있다.

### 숨겨진 비용
와일드카드를 사용하는 쿼리는 성능과 확장성 측면에서도 좋지 않다. 더 많은 컬럼을 호출하면 할수록 더 많은 데이터가 데이터베이스 서버와 어플리케이션 서버내 네트워크에 전송되게 된다.

당신의 앱 서버는 한번에 많은 쿼리를 동시에 호출하고 있을 것이다. 이 경우 각 쿼리들은 같은 네트워크 대역폭 내에서 각각 호출 될 것이다. 기가바이트 네트워크를 사용하고 있더라도 수천개의 로우를 수백개가 되는 앱 클라이언트에서 동시에 호출하게 된다면 금방 포화상태가 될 것이다.

Active Record 와 같은 객체 관계 매핑(ORM)에서는 와일드카드를 기본으로 테이블의 로우 데이터를 호출한다. ORM이 해당 기능을 오버라이딩 하는 기능을 제공함에도 많은 개발자들은 이를 크게 신경쓰지 않고 기본값을 활용하고 있다.

### 요청한대로 반환
많은 개발자들이 와일드카드를 사용할때 특정 컬럼만 제외하는 기능이 없는지 궁금해하곤 한다. 아마 데이터베이스에서 값을 호출 할 때 와일드카드를 사용하면서도 필요없는 데이터를 제외하고 싶은 마음에서 나온 질문일 것이다. 하지만 SQL에는 그러한 기능이 존재하지 않는다. 필요한 컬럼값만 반환하고 싶다면 컬럼명을 명시하는것 말고는 방법이 없다.

## 어떻게 안티패턴을 구분하는가
* 테이블의 컬럼명을 변경했음에도 변경 전 컬럼명을 참조하여 어플리케이션 전체가 제대로 동작하지 않는 경우<br>
컬럼명을 명시하지 않고 사용하는 경우 변경 내역을 일일이 추적하기가 어렵다.

* 네트워크 트래픽의 병목을 확인해본 결과 특정 쿼리에서 필요하지 않는 데이터들을 너무 많이 끌어다 오는 경우<br>
와일드카드를 남발하면 이런 현상이 발생 할 수 있다.

## 안티패턴 사용이 정당화 되는 경우
테스트를 위한 쿼리 작성이나 데이터 확인을 위해 전체를 조회하는 것과 같이 특정 목적을 수행하기 위해서는 와일드카드를 사용할 수도 있다. 하지만 프로덕션 코드에 와일드카드를 사용하는것은 필요하지 않은 데이터를 끌어다 쓰기 때문에 좋지 않다.

어플리케이션에서 컬럼 추가, 삭제, 컬럼명 변경 또는 재배열과 같은 작업이 빈번하게 일어난다면 와일드카드를 사용하는것이 가장 효율적이다. 하지만 문제가 발생하면 추적하는데 어려움을 겪을 수도 있으니 해당 부분은 명심해야 할 것이다.

또한 병합 테이블을 만들때 테이블명을 명시하여 와일드카드를 사용하면 편리하다.
```sql
SELECT b.*, a.first_name, a.email
FROM Bugs b JOIN Accounts a
  ON (b.reported_by = a.account_id);
```
이때 컬럼명을 일일이 열거하는것은 개발 효율성을 런타임 효율성보다 중요하게 생각하는 개발자들에게는 굉장히 비효율적인 작업이 될 수도 있다. 이는 순전히 개발자 개개인의 취향이기 때문에 본인에 취향에 맞추어 작업을 하면 된다.

또 한가지 언급할 만한 점은 데이터베이스에 장문의 쿼리를 넘기는 경우 아주 긴 네트워크 오버헤드가 발생한다는 점이다. 이론적으로 보았을땐 쿼리의 길이에 따라 오버헤드가 발생할 수도 있다. 하지만 쿼리 길이 때문에 발생하는 오버헤드보다 많은 양의 데이터를 호출하여 발생하는 네트워크 대역폭에 부하가 가는 것을 방지하는 것이 일반적으로 더 중요시된다. 이 또한 개발자 개개인의 판단의 몫이다.

## 해결책 - 명시적으로 컬럼명을 입력하기
와일드카드나 컬럼명을 입력하지 않고 쿼리를 작성하는것 보다 컬럼명을 명시하는 것이 가장 좋다.
```sql
SELECT bug_id, date_reported, summary, description, resolution,
  reported_by, assigned_to, verified_by, status, priority, hours
FROM Bugs;

INSERT INTO Accounts (account_name, first_name, last_name, email,
  password_hash, portrait_image, hourly_rate)
VALUES ('bkarwin', 'Bill', 'Karwin', 'bill@example.com',
  SHA2('xyzzy'), NULL, 49.95);
```
일일이 타이핑 하는것이 귀찮을순 있지만 이렇게 하는 것이 가장 좋은 방법이다.

### 실수 방지
앞에서 한번 언급했듯이 SELECT 문에서 컬럼명을 명시하면 에러나 모호함을 어느정도 해결 할 수 있다.
* 컬럼의 위치가 변경되더라도 해당 쿼리의 결과에서는 위치가 변경되지 않음.
* 새로운 컬럼이 추가되더라도 해당 쿼리의 결과에서는 나타나지 않음.
* 컬럼을 삭제하는 경우 기존 쿼리에서 에러가 발생한다. 에러가 발생하더라도 왜 발생했는지 어떤 조치를 취해야하는지 명확하기 때문에 큰 문제가 되지 않는다.

이와 비슷한 효과를 INSERT 문에서 컬럼명을 명시하면 가질수 있다. 컬럼의 위치가 변경되더라도 컬럼명을 나열해주었기 때문에 영향을 받지 않는다. 새로운 컬럼이 추가되더라도 로우 추가 시 에러가 발생하지 않고 기본값 또는 `null`로 대체된다. 컬럼이 삭제된 경우 동일하게 어떤 조치를 취해야 할 지 명확하기 때문에 큰 어려움을 겪지 않아도 된다.

이는 Fail-fast 원칙의 일종이다.

### 필요없는 데이터 제거
확장성과 [쓰루풋(스루풋 또는 처리율은 통신에서 네트워크 상의 어떤 노드나 터미널로부터 또 다른 터미널로 전달되는 단위 시간당 디지털 데이터 전송으로 처리하는 양을 말한다)](https://ko.wikipedia.org/wiki/%EC%8A%A4%EB%A3%A8%ED%92%8B)을 고려한다면 네트워크 대역폭에서 낭비되는 지점을 찾아야한다. SQL 쿼리의 대역폭은 개발과 테스트 단계에서는 큰 문제가 없는것처럼 보여도 프로덕션 환경에서는 한번에 수천개의 쿼리가 동시에 실행된다.

와일드카드를 사용을 하지 않는다면 자연스럽게 필요없는 컬럼을 참조하지 않게 된다. 이는 대역폭 향상에도 크게 도움이 된다.
```sql
SELECT date_reported, summary, description, resolution, status, priority
FROM Bugs;
```


> 이 글은 [SQL Antipatterns - by Bill Karwin](https://pragprog.com/titles/bksqla/sql-antipatterns/) 영문 원본의 Chapter19 를 요약한 글입니다. 자의적인 해석이 들어 간 것을 참고하셨으면 좋겠습니다.
