# Chapter 16 Random Selection (무작위 선택)

## 목표 - 샘플 로우 데이터 가져오기
우리는 앱을 개발하면서 종종 다음과 같은 이유로 무작위 로우를 출력해야 하는 비즈니스 로직을 만들어야 한다.

* 광고나 뉴스 하이라이트와 같이 매번 변경되는 컨텐츠를 노출시키는 경우.
* 데이터의 일부분만 검수하는 경우.
* 상담가능한 상담원에게 인바운드 전화를 넘기는 경우.
* 테스트 데이터를 생성하는 경우.

이런 경우 모든 데이터를 어플리케이션에 로딩하는 것 보다 샘플링 하여 불러 오는 것이 효율적이다. 이번 쳅터의 목표는 어떻게 효율적으로 데이터 샘플링을 할 수 있는지에 대해 다뤄보고자 한다.

## 안티패턴 - 무작위로 데이터 정렬하기
무작위 로우를 뽑는 가장 일반적인 SQL 트릭으로 무작위로 로우를 정렬한 다음 가장 첫번째 데이터를 뽑는 방식이 있다. 이 방식은 직관적이고 쉽게 적용 할 수 있다.
```sql
SELECT * FROM Bugs ORDER BY RAND() LIMIT 1;
```
이 방법이 가장 인기가 많긴 하지만 큰 단점도 있다. 이 단점을 이해하기 위해서는 기존에 사용하고 있던 정렬 방식, 즉 컬럼 값을 비교하고 오름차순 또는 내림차순으로 정렬하는 방식과 비교해보아야 한다. 이런 방식의 정렬은 여러번 실행 하더라도 동일한 결과를 출력하기 때문에 반복 가능하다. 또한 인덱스를 활용하기 때문에 빠르게 호출한다. 이는 기본적으로 인덱스가 이미 해당 컬럼을 정렬된 상태의 값들을 가지고 있기 때문이다.

```sql
SELECT * FROM Bugs ORDER BY date_reported;
```
정렬 기준이 로우 별로 무작위 값을 반환 한다면 해당 값이 다른 로우 값 또한 무작위로 선택되기 때문에 어떤 값이 크고 작은지 또한 무작위가 되어버린다. 결국 이 값은 각 로우마다 연관성이 전혀 없는 데이터셋을 반환한다. 그렇기 때문에 해당 쿼리를 실행할 때 마다 다른 값을 반환하게 된다. 여기까지는 우리가 원하는 진짜 무작위 데이터를 뽑는 가설에 충족하기 때문에 좋은 결과로 생각할 수도 있다.

`RAND()`와 같은 비결정론적 표현식을 정렬에 사용한다는 것은 인덱스를 활용하여 정렬을 할 수 없다는 것과 동일하다. 무작위 함수를 도울 수 있는 인덱스 같은 것은 없기 때문이다.

이것이 쿼리 성능을 저하시키는 원인이다. 인덱스를 사용하지 않기 때문에 정렬하는데 최적의 속도를 내지 못하기 때문이다. 인덱스를 사용하지 않게되면 데이터베이스 내에서 매번 실행 될 때마다 직접 정렬을 수행한다. 이를 테이블 `순차접근(full table scan)` 이라고 부르며 이 과정에서 모든 결과를 임시 테이블에 저장하고 직접 일일이 로우를 바꿔가며 정렬을 수행한다. 이런 순차접근 정렬 방식은 인덱스를 사용한 정렬 방식보다 훨씬 느리고 데이터셋이 커지면 커질수록 그 차이는 더 극심해진다.

또 다른 문제점은 이렇게 자원이 많이 소모되는 프로세스를 수행하지만 대부분의 데이터셋들이 버려진다는 점이다. 이는 대게 첫번째 로우를 제외하곤 필요없는 데이터이기 때문이다.

두가지 문제 모두 적은 데이터셋을 조회하는 경우 눈에 띄지 않기 때문에 개발 및 테스트 단계에서 잡아내기 어렵다. 이는 결국 데이터 양이 많아질수록 전체 데이터베이스의 성능을 저하시키는 원인이 된다.

## 어떻게 안티패턴을 구분하는가
작성중...

> 이 글은 [SQL Antipatterns - by Bill Karwin](https://pragprog.com/titles/bksqla/sql-antipatterns/) 영문 원본의 Chapter16 를 요약한 글입니다. 자의적인 해석이 들어 간 것을 참고하셨으면 좋겠습니다.
