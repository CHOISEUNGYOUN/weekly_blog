# 절대로 미래에 일어날 작업을 미리 스케쥴링 하지 마라!

작업을 하다보면 먼 미래에 일어날 작업을 예약하고 싶은 순간이 많이 있을 것이다. 고객이 상품을 사고 며칠 뒤에 그 상품이 얼마나 마음에 들었는지 확인하고 싶은 순간처럼 말이다. 아니면 새로운 유저가 가입한지 일주일 뒤에 특정 요약 지표를 기록하고 싶을지도 모른다.

어찌됐든, 그러한 이벤트들이 발생한 후로 며칠뒤에 실행 되는 작업들을 미리 작업 큐에 담아두지 마라. Sidekiq 이나 Amazon SQS 가 해당 작업들을 수행 할 수 있게 설계되어 있어도 말이다!

왜 미래에 일어나는 작업을 예악하는 것이 실수인지, 왜 그러한 작업을 두번 다시는 하지 않는지 내 경험을 바탕으로 설명을 하고자 한다. 마지막엔 동일한 기능을 수행하지만 훨씬 더 안전한 방법으로 수행할 수 있는 패턴 또한 소개하도록 하겠다.


## 미래에 일어나는 작업을 예약 하는것은 위험하다.
Sidekiq을 사용해 보았다면, 다음 예시 코드를 이해 할 수 있을 것이다.
```rb
PurchaseFollowUpEmailWorker.perform_in(3.days, purchase_id)
```
3알 뒤에 무슨 일이 벌어지겠는가? 예상하건데, 당신은 고객이 구매한 제품이 마음에 들었는지 물어보는 메일이 발송될 것이라고 생각 할 것이다. 그렇게 될거라고 어떻게 확신하는가? 테스트가 보장해준다고? 천만의 말씀이다!

**_딩신은 지금 시스템 작동방식과 작업 호출 사이에 잘못된 인과관계를 그리고있다!_**

당신이 설계한 테스트는 3일 전에 상품을 구매한 유저에게는 물어 볼 수 있지만 3일 뒤에 구매 할 유저에겐 어떻게 할 수 있는가? 어떠한 테스트도 현재 상황과 3일 뒤에 벌어질 차이점에 대해서 설명 할 수 없을 것이다.

이게 바로 왜 미래에 일어날 작업을 예약하는 것이 위험한 이유이다. 당신은 단지 검증 없이 워커에 예약을 걸어두는 것이다. 보통 논리 시스템을 구성할 때, `x` 와 `y` 가 true 이면 `z`를 실행하라고 코드를 짠다. 이러한 시스템의 테스트는 `x`, `y`, `z` 각각에 대한 의미를 이해하고 있기 때문에 안전하다. 즉, 테스트는 당신의 시스템의 여러 부분으로부터 예측 가능한 값들을 불러오기 땨문에 정확하고 의미있는 결과를 산출한다. 테스트에 대한 이런 일반적인 이해가 미래에 일어날 작업에는 통용되지 않는데, 그건 바로 아직 쓰지도 않은 코드를 테스트 할 수 없기 때문이다. 당신은 작업 호출(`x` 와 `y`)과 시스템 작동(`z`) 에 대해 잘못 이해하고 있다.


## 예를 들자면

**_당신은 과거의 예측을 고치기 위해 과거로 돌아갈 순 없지만, 시스템이 어떻게 작동할 지 정확하게 예측 할 수 있다._**

좀 간단하게 축약 했지만 실제로 일어날 법한 일에 빗대어 설명을 하자면, P2P 플랫폼은 과거에 유저가 구매한 상품에 따라 물건을 배송한다. 판매자가 물건을 7일내로 배송을 하지 않는다면, 구매자는 환불 받는다. 구매가 일어나면, 다음과 같은 작업이 예약된다.
```rb
RefundWorker.peform_in(7.days, purchase_id)
```

7일 뒤에 해당 작업은 다음과 같은 코드를 수행한다.
```rb
class RefundWorker
  include Sidekiq::Worker
  def perform(purchase_id)
    purchase = Purchase.find(purchased_id)
    purchase.refund! unless purchase.shipped?
  end
end
```

어느날, 팀에서 해당 시스템의 구성을 바꾸기로 결정했다. 이 작업은 모든 해당 작업들이 취소 될 리스크가 있는 Redis에 예약되어있기 때문에 미배송 제품, 환불되지 않은 제품과 이전 주문을 모두 야간 모니터링 해야하는 인원이 필요했다. 이러한 비효율을 유지하기 보단 다음 예시와 같이 처리해야 할 주문들을 조회하고 환불하는 작업으로 바꾸기로 했다.

```rb
class NightlyRefunder
  include Sidekiq::Worker
  def perform
    purchases = Purchase.unshipped.where('created_at < ?', 7.days.ago)
    purchases.pluck(:id).each do |purchase_id|
      RefundWorker.perform_async(purchase_id)
    end
  end
end
```

자 이제 우리가 해야될 건 상품 배송되지 않은 주문들만 환불하는 작업을 예약하면 된다.
```rb
class RefundWorker
  include Sidekiq::Worker
  def perform(purchase_id)
    Purchase.find(purchased_id).refund!
  end
end
```

문제는 이전 시스템이 이미 배포되어 실행되고 있었다는 것이다. 해당 코드를 짠 개발자는 `unless purchased.shipped?` 조건을 만족하는 수천개의 작업이 이미 예약되어 있다는 것을 잊고 있었다. 해당 작업의 호출 조건이 바뀌면 당연히 그 작업의 작동방식 또한 바뀌겠지만, 아까 말했듯이 당신은 과거로 돌아가서 과거에 예상했던 작업 조건을 바꿀순 없다. 단지 미래에 당신의 시스템이 어떻게 작동할지만 알 뿐이다.

여기서 볼 수 있듯이, 미래에 실행될 작업들을 삭제하는 것 이외에 다른 방법으로 해결 할 수 있었을 것이다. 다른 작업을 설계하여 지금 당장 예상되는 환불 작업들을 처리 할 수도 있었을 것이다. 다르게 생각해보면, 원래 설계 되었던 작업 시스템 네이밍이 잘못 되었을 수도 있다. `CheckRefundableWorker` 같이 단순히 환불 여부를 검사하는 작업을 설계하여 `NightlyRefunder` 에서 다시 사용하지 못하게 하는것이 훨씬 명확 했을수도 있다. 이전에 등록된 작업들은 새로운 코드가 배포될때 삭제 되었어야만 했다.

**_일을 어렵게 만들지 마라. 쉽게 할 수 있다._**

당연하게도, 미래에 일어날 작업을 예약하는 시스템을 좀 더 개선할 수 있는 여러 방법들이 존재한다. 하지만 이러한 작업들이 뭘 요구하는지 신중하게 다시 생각해보자. 위에 제시된 설계를 사용하면 당신의 동료 엔지니어들은 이전 시스템이 어떻게 작업을 실행하는지 완전히 이해하고 있어야 한다. 그런일은 정말 힘들다. 일을 어렵게 만들지 마라. 더 쉬운 방법으로 해결 할 수 있다. 과거에 작성해둔 코드에 대해서 검토하는 것을 하지 않아도 이미 프로그래밍은 충분히 어렵다.


## 더 쉽고 안전한 방법

이전에 작성해둔 코드를 검토하고 생각하느라 너 자신을 짓누르지 마라. 단지 지금 어떻게 시스템을 구성할지 생각하고 작성하라. 오늘 해당되는 모든 주문을 가져와서 작업 하나하나를 즉시 실행하도록 예약해라.

다른 작업들을 예약하는 배치 작업은 경쟁 상태(Race conditions: 프로그램이나 시스템 등의 실행/출력 결과가 일정하지 않고, 입력의 타이밍, 실행되는 순서나 시간 등에 영향을 받게 되는 상황. 결과가 매번 달라지므로 버그를 불러오기 딱 좋다. 출처-[나무위키:경쟁 상태](https://namu.wiki/w/%EA%B2%BD%EC%9F%81%20%EC%83%81%ED%83%9C))를 일으킬수 있다. 해당 작업이 멱등성(연산을 여러 번 적용하더라도 결과가 달라지지 않는 성질. 출처-[MDN:멱등성](https://developer.mozilla.org/ko/docs/Glossary/Idempotent))적이지 않는다면(아마 환불 이메일 발송 시스템이 있을 것이다.) 해당 작업이 리소스를 잠그도록 하면 된다(경쟁 상태를 방지하기 위해 다중 쓰레드를 올려놓지 말라는 의미인듯.)

```rb
class RefundWorker
  include Sidekiq::Worker
  def perform(purchase_id)
    purchase = Purchase.find(purchased_id)
    purchase.with_lock do
      purchase.refund! unless purchase.refunded?
    end
  end
end
```

## 할수 있다고 다 해야 하는게 아니다.
Amzon SQS 나 Sidekiq 처럼 인기있는 스케쥴링 툴들은 미래에 일어날 작업들을 예약 할 수 있도록 지원하지만, 내 생각에는 이러한 기능들이 너무 위험해 보인다. 당신은 미래에 실행될 작업을 예약할 때 어떠한 일이 벌어질지 모른다. 현재 코드가 나중에 어떻게 바뀔지 모르기 때문이다. 현재 예상되는 범위 내에서만 당신의 비즈니스 로직을 설계하고 실행해라.

