# 유니온(union)과 인터페이스(interface) 를 사용하여 GraphQL 에러 핸들링하기

의심할 여지 없이 GraphQL의 최고의 기능은 타입 시스템이다.

GraphQL 코드 제네레이터와 타입스크립트나 플로우(Flow)와 같은 자바스크립트 서브셋을 함께 활용하면 타입이 지정된 데이터를 순식간에 가져올 수 있다.

GraphQL을 사용한 이후로 GraphQL 없이 API를 개발하던 시절로 돌아갈 수 없을 지경이다. 그럼에도 불구하고 GraphQL을 처음 사용했을때 몇가지 문제점 때문에 다시 REST로 개발하고 싶은 순간들이 있었다. 그 중 하나는 바로 에러핸들링이 무척 불편하다는 점이다. 전통적인 HTTP 통신 방식에서는 각기 다른 상태 코드와 에러 메세지를 전달해줬다(또는 성공 메세지라던지).

GraphQL이 한창 인기를 얻고 있을때 아폴로 서버 터미널에서 에러 객체를 로깅할때 상태코드로 200과 함께 `ok` 라고 내려주던 밈(meme)이 유행했던 적이 있었다. 왜 GraphQL이 광범위하게 쓰이고 있던 규격을 깨고 있는지 궁금했었다. 좀 더 조사해본 뒤 GraphQL이 어떻게 에러를 좀 더 편하고 직관적인 방법으로 다룰 수 있는지 알게 되었다.

## GraphQL에서 에러 핸들링 하기

API 디자인을 어떻게 했는지 살펴보기 전에 에러 핸들링을 여기까지 하게 된 과정에 대해서 하나씩 살펴보고자 한다. 예시코드는 `react-apollo` 와 `apollo-server` 를 사용하여 구성하고자 한다. 이 두 툴을 사용하지 않더라도 GraphQL을 사용하는 어떤 클라이언트 및 서버 프레임워크에 적용 가능하니 참고하자.

우선 아래의 JSON 객체를 살펴보도록 하자.

```json
{
  "errors": [
    {
      "message": "Name for character with ID 1002 could not be fetched.",
      "locations": [ { "line": 6, "column": 7 } ],
      "path": [ "hero", "heroFriends", 1, "name" ]
    }
  ],
  "data": {
    "hero": {
      "name": "R2-D2",
      "heroFriends": [
        {
          "id": "1000",
          "name": "Luke Skywalker"
        },
        {
          "id": "1002",
          "name": null
        },
        {
          "id": "1003",
          "name": "Leia Organa"
        }
      ]
    }
  }
}
```
어디서 한번 본것 같지 않은가? 위 코드는 [GraphQL Spec Error Section](https://spec.graphql.org/draft/#example-90475)에서 가져왔다. 이미 GraphQL API를 어플리케이션에 적용했다면 이러한 응답 포멧에 익숙할 것이다.

GraphQL은 설계상 필드 값을 nullable 처리를 할 수 있다. 해당 데이터가 선택값으로 지정되었더라도 리졸버에서 에러 메세지를 반환한다면 부분적으로 결과값을 전달 할 수 있다. 이는 엄격한 REST 구조와 다른 요소중에 하나이다. `hero` 리졸버에서 에러를 반환하는 경우 (예시에서는 1002번 id) JSON 응답 객체에 key errors 배열을 추가하여 반환하게 된다. 이 배열은 어떤 에러인지에 대한 메세지를 담은 에러 객체와 경로, 쿼리 위치를 알려준다. 해당 리졸버 코드는 다음과 같다.

```js
const resolvers = {
  Hero: {
    name: (parent, args, context) => {
      throw new Error(
        "Name for character with ID 1002 could not be fetched."
      );
    },
  },
};
```
처음 이 구조를 보았을때 좋다고 생각했었다. 하지만 이내 좀 더 상태 코드와 같이 자세한 정보가 필요하다는 것을 알게 되었다. 예를 들자면 이 에러를 보고 사용자가 존재하지 않는지(REST 에서는 404) 사용자가 차단을 했는지(REST 에서는 406으로 표현 가능) 구분이 불가능한 것이다. 그리하여 GraphQL에서는 아래와 같이 익스텐션을 추가할 수 있게 되었다. 익스텐션은 말 그대로 에러 객체(또는 응답 객체)에 객체를 추가하는 것을 의미한다.

```json
{
  "errors": [
    {
      "message": "Name for character with ID 1002 could not be fetched.",
      "locations": [ { "line": 6, "column": 7 } ],
      "path": [ "hero", "heroFriends", 1, "name" ],
      "extensions": {
        "code": "CAN_NOT_FETCH_BY_ID",
        "timestamp": "Fri Feb 9 14:33:09 UTC 2018"
      }
    }
  ]
}
```

익스텐션을 활용하면 에러 객체에 코드를 적절히 추가할 수 있어 이를 클라이언트에서 활용할 수 있다. 이는 에러메세지를 직접 구문분석 하는 것 보다 좀 더 간편한 방법이다. Apollo 서버와 같은 프레임워크들은 에러 클래스를 선언하여 에러메세지를 돌려 주기도 한다.

```js
import {
  ApolloError,
}  from "apollo-server";

const resolvers = {
  Hero: {
    name: (parent, args, context) => {
      throw new ApolloError(
        "Name for character with ID 1002 could not be fetched.",
        "CAN_NOT_FETCH_BY_ID",
      );
    },
  },
};
```

필자 또한 위 방식과 같은 에러 핸들링 스타일을 빠르게 적용했지만 이 방법이 생산성 측면에서 장점보다는 단점이 많다는 점을 깨달았다.

## 에러는 발생이 예상되는 위치에 발생하지 않는다.

물론 어디에 이 에러가 발생하는지 알 순 있다. 클라이언트에서 에러 메세지를 찾는 커스텀 함수를 만들어서 관리를 할 수도 있다. 필자는 개인적으로 모든 에러는 어플리케이션의 UI 단에서 다뤄져야 한다고 생각한다. 에러 자체가 기본적으로 발생하는 위치 이외의 곳에서 발생하게 되는것은 개발자의 에러를 유연하게 처리하고자 하는 의지를 떨어뜨리기 마련이다. 게다가 `Relay`와 같은 프레임워크들은 `Fragment`들을 컴포넌트에 주입하도록 장려하고 있다. 에러 핸들링을 적절하게 하기 위해선 정확한 에러를 각 컴포넌트에 주입시켜주는 커스텀 로직을 구현해야 한다. 이는 필자가 피하고자 했던 추가 작업이지만 어쩔수 없게 되었다.

## GraphQL의 에러 익스텐션을 활용하는 것은 GraphQL의 타입 안정성을 해치는 작업이다.
앞서 말했듯이 GraphQL API의 가장 큰 장점 중 하나는 타입 안정성이다. 스키마는 기본적으로 자기 내부 검사 시스템을 통해 검증 될 수 있으며 모든 타입들과 필드들이 외부에 노출되어 있다. 하지만 에러 코드의 경우 스키마 내 어디에도 존재하지 않는다. (적어도 GraphQL 사양 내에서는 말이다.)

No type error will be thrown if you mistype the error message or extension code inside your resolvers.

The GraphQL engine does not care about the structure of the message.

Furthermore, the error code is just an optional extension. I am not currently aware of any tool that generates type-safe error codes, nor can you see an overview of all available error codes that a field (or resolver) could throw.

## When using the errors array, we’re back in good old type guessing land.
Backend and frontend developers now have one more pain to deal with (one that they actually tried to avoid by switching over to GraphQL in the first place.)

Don’t misunderstand me — even if you have a fully-typed GraphQL API, there should still be some documentation.

The API browser generated by tools like GraphiQL or GraphQL Playground should make it easier to discover and understand what a GraphQL API provides, but it shouldn’t replace a documentation with usage examples.

## We can do it better with the existing GraphQL primitives
Recently, there has been a lot of buzz around using union types for handling errors. A union type represents a list of objects that a field can return.

```graphql
type User {
  id: ID!
  login: String!
}

type UserNotFoundError {
  message: String!
}

union UserResult = User | UserNotFoundError

type Query {
  user(id: ID!): UserResult!
}
```

In the following schema, the field `user` can either return a `User` or `UserNotFoundError`. Instead of throwing an error inside our resolver, we simply return a different type.

The query that you would send to your server would look like this:

```graphql
query user($id: ID!) {
  user(id: $id) {
    ... on UserNotFoundError {
      message
    }
    ... on User {
      id
      login
    }
  }
}
```
Accordingly, the `apollo-server` resolver could look similar to the following:

```js
const resolvers = {
  Query: {
    user: async (parent, args, context) => {
      const userRecord = await context.db.findUserById(args.id);
      if (userRecord) {
        return {
          __typename: "User",
          ...userRecord,
        };
      }
      return {
        __typename: "UserNotFound",
        message: `The user with the id ${args.id} does not exist.`,
      };
    },
  },
};
```

When using unions, you will have to return a `__typename` so `apollo-server` knows which type the result has and which resolver map must be used for resolving further field values of the resolved type.

This allows us to model errors like normal GraphQL types. This way, we regain the power of type safety: instead of working with a message and an error code, we can have more complex types.

Below is an example of a login mutation that returns the `UserRegisterInvalidInputError` error type.

Despite having a generic error message, the type also provides fields for the single input fields.

```graphql
type User {
  id: ID!
  login: String!
}

type UserRegisterResultSuccess {
  user: User!
}

type UserRegisterInvalidInputError {
  message: String!
  loginErrorMessage: String
  emailErrorMessage: String
  passwordErrorMessage: String
}

input UserRegisterInput {
  login: String!
  email: String!
  password: String!
}

union UserRegisterResult = UserRegisterResultSuccess | UserRegisterInvalidInputError

type Mutation {
  userRegister(input: UserRegisterInput!): UserRegisterResult!
}
```

You could even go further and add fields that return new, more complex `object` types.

A client implementation could look like similar to this:

```js
import React, { useState } from "react";
import { useUserRegisterMutation } from "./generated-types"
import idx from "idx";
import { useFormState } from 'react-use-form-state';

const RegistrationForm: React.FC<{}> = () => {
  const [userRegister, { loading, data }] = useUserRegisterMutation();
  const loginState = useFormState("login");
  const emailState = useFormState("email");
  const passwordState = useFormState("password");

  useEffect(() => {
    if (idx(data, d => d.userRegister.__typename) === "UserRegisterResultSuccess") {
      alert("registration success!");
    }
  }, [data]);

  return (
    <form
      onSubmit={(ev) => {
        ev.preventDefault();
        userRegister();
      }}
    >
      <InputField
        {...loginState}
        error={idx(data, d => d.userRegister.loginErrorMessage)}
      />
      <InputField
        {...emailState}
        error={idx(data, d => d.userRegister.emailErrorMessage)}
      />
      <InputField
        {...passwordState}
        error={idx(data, d => d.userRegister.passwordErrorMessage)}
      />
      <SubmitButton />
      {idx(data, d => d.userRegister.message) || null}
      {loading ? <LoadingSpinner /> : null}
    </form>
  )
}
```

## GraphQL gives you the power to shape your data tree according to your UI
That’s why you should also shape your error types according to the UI.

In case you have different types of errors, you can create a type for each of them and add them to your union list:

```graphql
type User {
  id: ID!
  login: String!
}

type UserRegisterResultSuccess {
  user: User!
}

type UserRegisterInvalidInputError {
  message: String!
  loginErrorMessage: String
  emailErrorMessage: String
  passwordErrorMessage: String
}

type CountryBlockedError {
  message: String!
}

type UserRegisterInput {
  login: String!
  email: String!
  password: String!
}

union UserRegisterResult =
  UserRegisterResultSuccess
  | UserRegisterInvalidInputError
  | CountryBlockedError

type Mutation {
  userRegister(input: UserRegisterInput!): UserRegisterResult!
}
```

This allows each error type to have their unique properties.

Let’s jump over the the frontend part of this requirement:

> You have a new requirement for your API: people from country X should not be allowed to register anymore, due to some weird sanctions of the country your company operates from.

Seems pretty straightforward, just add some new types on the backend, right?

Unfortunately, no. The frontend developer will now also have to update his query because a new type of error, that is not covered by any selection set is now being returned.

This means that the following query:

```graphql
mutation userRegister($input: UserRegisterInput!) {
  userRegister(input: $input) {
    __typename
    ... on UserRegisterResultSuccess {
      user {
        id
        login
      }
    }
    ... on UserRegisterInvalidInputError {
      message
      loginErrorMessage
      emailErrorMessage
      passwordErrorMessage
    }
  }
}
```
Needs to be updated to this:

```graphql
mutation userRegister($input: UserRegisterInput!) {
  userRegister(input: $input) {
    __typename
    ... on UserRegisterResultSuccess {
      user {
        id
        login
      }
    }
    ... on UserRegisterInvalidInputError {
      message
      loginErrorMessage
      emailErrorMessage
      passwordErrorMessage
    }
    ... on CountryBlockedError {
      message
    }
  }
}
```
Otherwise, the client will not receive an error message for the `CountryBlockedError` that can be displayed.

Forcing the developer of the client application to adjust their GraphQL documents every time we add some new error type does not seem like a clever solution.

Let’s take a closer look at our error objects:

```graphql
type UserRegisterInvalidInputError {
  message: String!
  loginErrorMessage: String
  emailErrorMessage: String
  passwordErrorMessage: String
}

type CountryBlockedError {
  message: String!
}
```
They both have one common property: `message`

Furthermore, we might assume that every error that will be potentially added to a union in the future will also have a message property.

Fortunately, GraphQL provides us with `interfaces`, that allow us to describe such an abstraction.

```graphql
interface Error {
  message: String!
}
```

An interface describes fields that can be implemented/shared by different types:

```graphql
interface Node {
  id: ID!
}

type User implements Node {
  id: ID!
  login: String!
}

type Post implements Node {
  id: ID!
  title: String!
  body: String!
}

type Query {
  entity(id: ID!): Node
}
```

For queries, the power of interfaces lies in being able to declare a data selection trough an interface instead of a type.

That means our previous schema can be transformed into the following:

```graphql
type User {
  id: ID!
  login: String!
}

interface Error {
  message: String!
}

type UserRegisterResultSuccess {
  user: User!
}

type UserRegisterInvalidInputError implements Error {
  message: String!
  loginErrorMessage: String
  emailErrorMessage: String
  passwordErrorMessage: String
}

type CountryBlockedError implements Error {
  message: String!
}

type UserRegisterInput {
  login: String!
  email: String!
  password: String!
}

union UserRegisterResult =
  UserRegisterResultSuccess
  | UserRegisterInvalidInputError
  | CountryBlockedError

type Mutation {
  userRegister(input: UserRegisterInput!): UserRegisterResult!
}
```

Both error types now implement the Error interface.

We can now adjust our query to the following:

```graphql
mutation userRegister($input: UserRegisterInput!) {
  userRegister(input: $input) {
    __typename
    ... on UserRegisterResultSuccess {
      user {
        id
        login
      }
    }
    ... on Error {
      message
    }
    ... on UserRegisterInvalidInputError {
      loginErrorMessage
      emailErrorMessage
      passwordErrorMessage
    }
  }
}
```

No need to even declare the `CountryBlockedError` selection set anymore. It is automatically covered by the Error selection set.

Furthermore, if any new type that implements the `Error` interface is added to the `UserRegisterResult` union, the error message will be automatically included in the result.

Of course, you will still have to add some logic on the client for handling your error state, but instead of explicitly handling every single error you can switch between the ones that need some more work, like `UserRegisterInvalidInputError`, and all these other errors that only show some sort of dialog, like `CountryBlockedError`.

E.g. if you follow the convention of ending all your error type with the word `Error` , you can build an abstraction that will handle multiple error types.

```js
import React, { useState } from "react";
import { useUserRegisterMutation } from "./generated-types"
import idx from "idx";
import { useAlert } from "./alert";

const RegistrationForm: React.FC<{}> = () => {
  const [userRegister, { loading, data }] = useUserRegisterMutation();
  const loginState = useFormState("login");
  const emailState = useFormState("email");
  const passwordState = useFormState("password");
  const showAlert = useAlert();

  useEffect(() => {
    const typename = idx(data, d => d.userRegister.__typename)
    if (typename === "UserRegisterResultSuccess") {
      alert("registration success!");
    } else if (typename.endsWith("Error")) {
      showAlert(data.userRegister.message);
    }
  }, [data]);

  return (
    <form
      onSubmit={(ev) => {
        ev.preventDefault();
        userRegister();
      }}
    >
      <InputField
        {...loginState}
        error={idx(data, d => d.userRegister.loginErrorMessage)}
      />
      <InputField
        {...emailState}
        error={idx(data, d => d.userRegister.emailErrorMessage)}
      />
      <InputField
        {...passwordState}
        error={idx(data, d => d.userRegister.passwordErrorMessage)}
      />
      <SubmitButton />
      {loading ? <LoadingSpinner /> : null}
    </form>
  )
}
```

At a later point in time when your team decides that a new error should be handled different from the others, you can adjust the code by adding a new else/if statement in useEffect.


Original Source:
[Handling GraphQL errors like a champ with unions and interfaces](https://blog.logrocket.com/handling-graphql-errors-like-a-champ-with-unions-and-interfaces)